<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>パパの歯みがきゲーム</title>
  <style>
    body { margin: 0; background: #dce9ff; font-family: "Hiragino Sans", "Noto Sans JP", sans-serif; }
    #ui { position: absolute; top: 12px; left: 12px; background: rgba(255,255,255,0.9); padding: 10px 14px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.12); line-height: 1.6; max-width: 560px; }
    #resetBtn { margin-top: 6px; padding: 6px 12px; border: none; border-radius: 8px; background: #4aa3ff; color: #fff; font-weight: 700; cursor: pointer; box-shadow: 0 3px 10px rgba(0,0,0,0.15); }
    canvas { display: block; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #e6f3ff; margin-left: 6px; font-weight: 600; }
  </style>
</head>
<body>
  <div id="ui">
    1) 山をクリック長押しで登る（左右移動＋風＋落石回避） → 2) 食材をドラッグでパパの口へ、ハズレは時間ペナルティ → 3) 歯みがき。<br />
    各フェーズ残り時間: <span id="time" class="pill">--</span> 秒 / 平均きれい度: <span id="avg" class="pill">-</span>%<br />
    リスタートはボタンから。
    <button id="resetBtn">リスタート</button>
  </div>
  <canvas id="c"></canvas>
  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const uiAvg = document.getElementById('avg');
    const uiTime = document.getElementById('time');
    const resetBtn = document.getElementById('resetBtn');

    // modes: climb | eat | playing | cleared | timeoutClimb | timeoutEat | timeoutBrush
    let mode = 'climb';

    // climb state
    const climber = { x: 0, y: 0, vy: 0 };
    let climbBaseY = 0;
    let climbTopY = 0;
    let mountain = null;
    let holdUp = false;
    let rocks = [];
    let rockSpawn = 0;
    const climbTotalTime = 25;
    let climbTimeLeft = climbTotalTime;
    let windPhase = 0;

    // eat state
    const foods = [];
    let mouthTarget = { x: 0, y: 0 };
    const eatTotalTime = 25;
    let eatTimeLeft = eatTotalTime;
    let draggingFood = null;
    let dragOffset = { x: 0, y: 0 };

    // brush game state
    const teeth = [];
    const cols = 6;
    const rows = 2;
    let layout = null;
    const brushTotalTime = 45;
    let brushTimeLeft = brushTotalTime;

    // shared input
    let brushing = false;
    let lastX = 0, lastY = 0;

    // audio
    let audioCtx = null;
    let bgmGain = null;
    let bgmOsc = null;
    let bgmTimer = null;
    let bgmChordOsc = [];
    let bgmBass = null;
    let bgmBell = null;
    let bgmBellTimer = null;

    resetBtn.addEventListener('click', resetGame);

    function ensureAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      bgmGain = audioCtx.createGain();
      bgmGain.gain.value = 0.05;
      bgmGain.connect(audioCtx.destination);
      startBgm();
    }

    function startBgm() {
      if (!audioCtx || bgmOsc) return;
      // lead
      bgmOsc = audioCtx.createOscillator();
      bgmOsc.type = 'sine';
      const lfo = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      lfo.frequency.value = 3.2;
      lfoGain.gain.value = 5;
      lfo.connect(lfoGain).connect(bgmOsc.frequency);

      // chords
      const chordGain = audioCtx.createGain();
      chordGain.gain.value = 0.04;
      chordGain.connect(bgmGain);
      bgmChordOsc = [0, 0].map(() => {
        const o = audioCtx.createOscillator();
        o.type = 'triangle';
        o.connect(chordGain);
        return o;
      });

      // bass
      bgmBass = audioCtx.createOscillator();
      const bassGain = audioCtx.createGain();
      bassGain.gain.value = 0.06;
      bgmBass.type = 'square';
      bgmBass.connect(bassGain).connect(bgmGain);

      // bell / arpeggio
      bgmBell = audioCtx.createOscillator();
      const bellGain = audioCtx.createGain();
      bellGain.gain.value = 0.03;
      bgmBell.type = 'sine';
      bgmBell.connect(bellGain).connect(bgmGain);

      // simple I-V-vi-IV loop in C: C(261) G(392) Am(440) F(349)
      const progression = [
        [261, 329], // C + E
        [392, 494], // G + B
        [440, 523], // A + C
        [349, 440], // F + A
      ];
      const bassNotes = [65, 49, 55, 44]; // C2, G1, A1, F1
      const melody = [262, 330, 392, 523, 494, 392, 330, 294, 262];
      const bellSeq = [784, 659, 698, 784, 880, 784, 698, 659];
      let mIdx = 0;
      let chordIdx = 0;
      bgmTimer = setInterval(() => {
        const chord = progression[chordIdx % progression.length];
        bgmChordOsc[0].frequency.setValueAtTime(chord[0], audioCtx.currentTime);
        bgmChordOsc[1].frequency.setValueAtTime(chord[1], audioCtx.currentTime);
        bgmBass.frequency.setValueAtTime(bassNotes[chordIdx % bassNotes.length], audioCtx.currentTime);
        bgmOsc.frequency.setValueAtTime(melody[mIdx % melody.length], audioCtx.currentTime);
        mIdx++;
        if (mIdx % 4 === 0) chordIdx++;
      }, 460);

      // bell/arpeggio on a shorter loop
      let bellIdx = 0;
      bgmBellTimer = setInterval(() => {
        bgmBell.frequency.setValueAtTime(bellSeq[bellIdx % bellSeq.length], audioCtx.currentTime);
        bellIdx++;
      }, 240);

      bgmOsc.frequency.value = melody[0];
      bgmBass.frequency.value = bassNotes[0];
      bgmBell.frequency.value = bellSeq[0];
      bgmOsc.connect(bgmGain);
      bgmOsc.start();
      lfo.start();
      bgmChordOsc.forEach(o => o.start());
      bgmBass.start();
      bgmBell.start();
    }

    function stopBgm() {
      if (bgmTimer) { clearInterval(bgmTimer); bgmTimer = null; }
      if (bgmBellTimer) { clearInterval(bgmBellTimer); bgmBellTimer = null; }
      bgmChordOsc.forEach(o => { try { o.stop(); } catch (_) {} o.disconnect?.(); });
      bgmChordOsc = [];
      if (bgmBass) { try { bgmBass.stop(); } catch (_) {} bgmBass.disconnect?.(); bgmBass = null; }
      if (bgmBell) { try { bgmBell.stop(); } catch (_) {} bgmBell.disconnect?.(); bgmBell = null; }
      if (bgmOsc) { try { bgmOsc.stop(); } catch (_) {} bgmOsc.disconnect(); bgmOsc = null; }
    }

    function playTone(freq, dur = 0.15, vol = 0.25) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.value = freq;
      gain.gain.value = vol;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
      osc.stop(audioCtx.currentTime + dur + 0.05);
    }

    function playClick() { playTone(520, 0.1, 0.15); }
    function playEat() { playTone(340, 0.18, 0.25); }
    function playBad() { playTone(120, 0.3, 0.35); }
    function playHit() { playTone(180, 0.12, 0.3); }
    function playClear() { [660, 880, 1040].forEach((f, i) => setTimeout(() => playTone(f, 0.12, 0.28), i * 80)); }

    function resetGame() {
      mode = 'climb';
      setupClimb();
      brushTimeLeft = brushTotalTime;
      eatTimeLeft = eatTotalTime;
      climbTimeLeft = climbTotalTime;
      draggingFood = null;
      initFoods();
      initTeeth();
      brushesOff();
    }

    function brushesOff() {
      brushing = false;
      holdUp = false;
      draggingFood = null;
    }

    function resize() {
      canvas.width = innerWidth;
      canvas.height = innerHeight;
      layout = computeLayout();
      mouthTarget = { x: layout.mouth.x + layout.mouth.w / 2, y: layout.mouth.y + layout.mouth.h * 0.55 };
      setupClimb();
      initTeeth();
      initFoods();
      brushTimeLeft = brushTotalTime;
      eatTimeLeft = eatTotalTime;
      climbTimeLeft = climbTotalTime;
      mode = 'climb';
      draggingFood = null;
    }
    window.addEventListener('resize', resize);
    resize();

    function setupClimb() {
      const w = canvas.width;
      const h = canvas.height;
      mountain = {
        peakX: w * 0.5,
        peakY: h * 0.24,
        leftX: w * 0.15,
        rightX: w * 0.85,
        baseY: h * 0.86
      };
      climber.x = w * 0.5;
      climber.y = mountain.baseY;
      climber.vy = 0;
      climbBaseY = mountain.baseY;
      climbTopY = mountain.peakY + 20;
      holdUp = false;
      rocks = [];
      rockSpawn = 0.4;
      windPhase = 0;
    }

    function computeLayout() {
      const w = canvas.width;
      const h = canvas.height;
      const minDim = Math.min(w, h);
      const headR = minDim * 0.42;
      const mouthW = minDim * 0.55;
      const mouthH = mouthW * 0.35;
      const centerX = w * 0.5;
      const centerY = h * 0.55;
      return {
        head: { cx: centerX, cy: h * 0.48, rx: headR, ry: headR * 0.92 },
        mouth: { x: centerX - mouthW / 2, y: centerY - mouthH / 2, w: mouthW, h: mouthH },
        eyes: {
          left: { x: w * 0.42, y: h * 0.32 },
          right: { x: w * 0.58, y: h * 0.32 },
          r: minDim * 0.018
        }
      };
    }

    function initTeeth() {
      teeth.length = 0;
      const padX = layout.mouth.w * 0.08;
      const padY = layout.mouth.h * 0.10;
      const slotW = (layout.mouth.w - padX * 2) / cols;
      const toothW = slotW * 0.9;
      const toothH = layout.mouth.h * 0.22;
      const upperY = layout.mouth.y + padY;
      const lowerY = layout.mouth.y + layout.mouth.h / 2 + padY * 0.6;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const baseX = layout.mouth.x + padX + c * slotW + (slotW - toothW) / 2;
          const arcOffset = Math.abs(c - (cols - 1) / 2) * 3;
          const y = (r === 0 ? upperY + arcOffset : lowerY - arcOffset);
          teeth.push({
            x: baseX,
            y,
            w: toothW,
            h: toothH,
            clean: Math.random() * 25 // 0 dirty, 100 clean
          });
        }
      }
    }

    function initFoods() {
      foods.length = 0;
      const plateR = canvas.width * 0.18;
      const centerX = canvas.width * 0.5;
      const centerY = canvas.height * 0.82;
      const pool = [
        { type: 'onigiri', isFood: true },
        { type: 'steak', isFood: true },
        { type: 'pork', isFood: true },
        { type: 'salmon', isFood: true },
        { type: 'carrot', isFood: true },
        { type: 'broccoli', isFood: true },
        { type: 'sausage', isFood: true },
        { type: 'onigiri', isFood: true },
        { type: 'rock', isFood: false },
        { type: 'eraser', isFood: false },
        { type: 'pencil', isFood: false }
      ];
      const items = shuffle(pool).slice(0, 9); // mix of foods & decoys
      items.forEach((item, i) => {
        const angle = (i / items.length) * Math.PI * 2;
        const r = plateR * 0.65;
        const x = centerX + Math.cos(angle) * r + (Math.random() - 0.5) * 12;
        const y = centerY + Math.sin(angle) * r * 0.4 + (Math.random() - 0.5) * 10;
        const seeds = Array.from({ length: 18 }, () => ({
          x: (Math.random() - 0.5) * 18,
          y: (Math.random() - 0.5) * 12,
          r: Math.random() * 1.5 + 0.5
        }));
        foods.push({
          x,
          y,
          startX: x,
          startY: y,
          targetX: mouthTarget.x,
          targetY: mouthTarget.y,
          eaten: false,
          done: false,
          t: 0,
          seeds,
          type: item.type,
          isFood: item.isFood,
          badFlash: 0
        });
      });
    }

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function startEatPhase() {
      mode = 'eat';
      holdUp = false;
      brushing = false;
      eatTimeLeft = eatTotalTime;
      initFoods();
      playTone(740, 0.15, 0.2);
    }

    function startBrushPhase() {
      mode = 'playing';
      brushTimeLeft = brushTotalTime;
      brushing = false;
      playTone(620, 0.12, 0.2);
    }

    // inputs (mouse only)
    canvas.addEventListener('mousedown', (e) => {
      ensureAudio();
      playClick();
      setPos(e);
      if (mode === 'climb') {
        holdUp = true;
      } else if (mode === 'eat') {
        const target = findFoodAt(lastX, lastY);
        if (target) {
          draggingFood = target;
          dragOffset.x = target.x - lastX;
          dragOffset.y = target.y - lastY;
        }
      } else if (mode === 'playing') {
        brushing = true;
      }
    });
    canvas.addEventListener('mouseup', () => {
      if (mode === 'eat' && draggingFood) {
        dropFood();
      }
      draggingFood = null;
      brushing = false;
      holdUp = false;
    });
    canvas.addEventListener('mouseleave', () => {
      draggingFood = null;
      brushing = false;
      holdUp = false;
    });
    canvas.addEventListener('mousemove', (e) => {
      setPos(e);
      if (mode === 'eat' && draggingFood) {
        draggingFood.x = lastX + dragOffset.x;
        draggingFood.y = lastY + dragOffset.y;
      }
    });

    function setPos(e) {
      const rect = canvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
    }

    function findFoodAt(x, y) {
      for (let i = foods.length - 1; i >= 0; i--) {
        const f = foods[i];
        if (f.done || f.eaten) continue;
        const dx = x - f.x;
        const dy = y - f.y;
        if (dx * dx + dy * dy < 34 * 34) return f;
      }
      return null;
    }

    function dropFood() {
      const f = draggingFood;
      draggingFood = null;
      const dx = f.x - mouthTarget.x;
      const dy = f.y - mouthTarget.y;
      const nearMouth = dx * dx + dy * dy < 120 * 120;
      if (!nearMouth) {
        f.x = f.startX;
        f.y = f.startY;
        return;
      }
      if (!f.isFood) {
        eatTimeLeft = Math.max(0, eatTimeLeft - 5);
        f.badFlash = 0.9;
        playBad();
        f.x = f.startX;
        f.y = f.startY;
        return;
      }
      f.eaten = true;
      f.t = 0;
      playEat();
    }

    function update(dt) {
      if (mode === 'climb') {
        climbTimeLeft = Math.max(0, climbTimeLeft - dt);
        rockSpawn -= dt;
        windPhase += dt * 0.7;
        const wind = Math.sin(windPhase) * 70;
        if (rockSpawn <= 0) {
          const rx = mountain.leftX + Math.random() * (mountain.rightX - mountain.leftX);
          rocks.push({ x: rx, y: mountain.peakY - 40, vy: 230 + Math.random() * 120, r: 12 + Math.random() * 8 });
          rockSpawn = 0.45 + Math.random() * 0.5;
        }
        rocks = rocks.filter(r => {
          r.y += r.vy * dt;
          r.x += Math.sin(r.y * 0.02) * 15 * dt;
          return r.y < climbBaseY + 50;
        });

        const upForce = holdUp ? -520 : 0;
        const gravity = 400;
        climber.vy += (upForce + gravity) * dt;
        climber.y += climber.vy * dt;
        const targetX = Math.min(Math.max(lastX + wind, mountain.leftX), mountain.rightX);
        climber.x += (targetX - climber.x) * 0.16;
        if (climber.y > climbBaseY) { climber.y = climbBaseY; climber.vy = 0; }
        if (climber.y <= climbTopY) {
          startEatPhase();
        }
        for (const r of rocks) {
          const dx = climber.x - r.x;
          const dy = (climber.y - 18) - r.y;
          if (dx * dx + dy * dy < (r.r + 14) * (r.r + 14)) {
            climber.y = Math.min(climbBaseY, climber.y + 120);
            climber.vy = 120;
            holdUp = false;
            playHit();
            break;
          }
        }
        if (climbTimeLeft <= 0) {
          mode = 'timeoutClimb';
        }
        return;
      }

      if (mode === 'eat') {
        eatTimeLeft = Math.max(0, eatTimeLeft - dt);
        foods.forEach(f => {
          if (f.badFlash > 0) f.badFlash = Math.max(0, f.badFlash - dt);
          if (!f.eaten || f.done) return;
          f.t += dt;
          const p = Math.min(1, f.t / 0.9);
          const ease = p * p * (3 - 2 * p);
          f.x = f.startX + (f.targetX - f.startX) * ease;
          f.y = f.startY + (f.targetY - f.startY) * ease - Math.sin(p * Math.PI) * 20;
          if (p >= 1) {
            f.done = true;
          }
        });
        const allFoodsEaten = foods.filter(f => f.isFood).every(f => f.done);
        if (allFoodsEaten) {
          startBrushPhase();
        } else if (eatTimeLeft <= 0) {
          mode = 'timeoutEat';
        }
        return;
      }

      if (mode !== 'playing') return;
      brushTimeLeft = Math.max(0, brushTimeLeft - dt);

      if (brushing) {
        const radius = Math.max(18, 30 + Math.sin(Date.now() * 0.01) * 6);
        teeth.forEach(t => {
          const cx = Math.max(t.x, Math.min(lastX, t.x + t.w));
          const cy = Math.max(t.y, Math.min(lastY, t.y + t.h));
          const dx = lastX - cx, dy = lastY - cy;
          const dist2 = dx * dx + dy * dy;
          if (dist2 < radius * radius) {
            const strength = Math.max(0, 1 - Math.sqrt(dist2) / radius);
            t.clean = Math.min(100, t.clean + strength * dt * 0.28 * 100);
          }
        });
      }

      if (brushTimeLeft <= 0) {
        mode = 'timeoutBrush';
      }
    }

    function drawClimb() {
      const w = canvas.width, h = canvas.height;
      const sky = ctx.createLinearGradient(0, 0, 0, h);
      sky.addColorStop(0, '#cde6ff');
      sky.addColorStop(1, '#e9f4ff');
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, w, h);

      ctx.fillStyle = '#86a6b8';
      ctx.beginPath();
      ctx.moveTo(mountain.leftX, mountain.baseY);
      ctx.lineTo(mountain.peakX, mountain.peakY);
      ctx.lineTo(mountain.rightX, mountain.baseY);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#a9c7d6';
      ctx.beginPath();
      ctx.moveTo(mountain.leftX + 40, mountain.baseY);
      ctx.lineTo(mountain.peakX, mountain.peakY + 40);
      ctx.lineTo(mountain.peakX + 20, mountain.baseY);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#f5d3b5';
      ctx.fillRect(mountain.peakX - 3, mountain.peakY - 70, 6, 70);
      ctx.fillStyle = '#ff4f64';
      ctx.beginPath();
      ctx.moveTo(mountain.peakX + 3, mountain.peakY - 65);
      ctx.lineTo(mountain.peakX + 75, mountain.peakY - 50);
      ctx.lineTo(mountain.peakX + 3, mountain.peakY - 35);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#5f5f5f';
      rocks.forEach(r => {
        ctx.beginPath();
        ctx.ellipse(r.x, r.y, r.r, r.r * 0.9, 0, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.fillStyle = '#3b2b23';
      ctx.beginPath();
      ctx.arc(climber.x, climber.y - 18, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#4aa3ff';
      ctx.fillRect(climber.x - 10, climber.y - 8, 20, 28);
      ctx.fillStyle = '#f5d3b5';
      ctx.beginPath();
      ctx.arc(climber.x, climber.y - 28, 10, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#234';
      ctx.font = '22px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('クリック長押しで上昇。マウス左右で位置調整。風＋落石に注意！', w / 2, h * 0.9);
      ctx.fillText(`登頂まであと: ${(Math.max(0, climber.y - climbTopY)).toFixed(0)} px / 残り ${Math.ceil(climbTimeLeft)} 秒`, w / 2, h * 0.94);
    }

    function clamp01(v) { return Math.max(0, Math.min(1, v)); }

    function drawSparkle(x, y, s = 10, alpha = 0.8) {
      ctx.save();
      ctx.translate(x, y);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.beginPath();
      ctx.moveTo(0, -s);
      ctx.lineTo(s * 0.3, -s * 0.3);
      ctx.lineTo(s, 0);
      ctx.lineTo(s * 0.3, s * 0.3);
      ctx.lineTo(0, s);
      ctx.lineTo(-s * 0.3, s * 0.3);
      ctx.lineTo(-s, 0);
      ctx.lineTo(-s * 0.3, -s * 0.3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawFaceBase(mood = 0) {
      const { head, mouth, eyes } = layout;
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#dce9ff');
      grad.addColorStop(1, '#f5fbff');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#f2c8a8';
      ctx.beginPath();
      ctx.ellipse(head.cx, head.cy, head.rx * 1.02, head.ry * 0.9, 0, 0, Math.PI * 2);
      ctx.fill();
      // stronger jaw line for a cool look
      const jawW = head.rx * 0.9;
      const jawH = head.ry * 0.35;
      ctx.fillStyle = '#f0c0a0';
      ctx.beginPath();
      ctx.moveTo(head.cx - jawW * 0.75, head.cy + head.ry * 0.15);
      ctx.lineTo(head.cx - jawW * 0.55, head.cy + jawH);
      ctx.lineTo(head.cx, head.cy + jawH + 12);
      ctx.lineTo(head.cx + jawW * 0.55, head.cy + jawH);
      ctx.lineTo(head.cx + jawW * 0.75, head.cy + head.ry * 0.15);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = 'rgba(80,40,20,0.25)';
      ctx.lineWidth = 2.5;
      ctx.stroke();

      ctx.beginPath();
      ctx.ellipse(head.cx - head.rx * 0.92, head.cy + 10, head.rx * 0.18, head.ry * 0.20, 0, 0, Math.PI * 2);
      ctx.ellipse(head.cx + head.rx * 0.92, head.cy + 10, head.rx * 0.18, head.ry * 0.20, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#2b1b15';
      ctx.beginPath();
      ctx.ellipse(head.cx, head.cy - head.ry * 0.45, head.rx * 0.95, head.ry * 0.55, 0, Math.PI, 0, true);
      ctx.fill();

      const squint = clamp01(mood);
      ctx.fillStyle = '#fff';
      [eyes.left, eyes.right].forEach(e => {
        ctx.beginPath();
        ctx.ellipse(e.x, e.y, head.rx * 0.12, head.ry * (0.10 - 0.04 * squint), 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.ellipse(e.x, e.y + squint * 2, eyes.r, eyes.r * (1.1 - 0.4 * squint), 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(e.x + eyes.r * 0.35, e.y - eyes.r * 0.15, eyes.r * 0.32, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#3b2b23';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(e.x - head.rx * 0.14, e.y - head.ry * (0.20 + 0.05 * (1 - squint)));
        ctx.quadraticCurveTo(e.x, e.y - head.ry * (0.26 + 0.05 * squint), e.x + head.rx * 0.14, e.y - head.ry * (0.20 + 0.05 * (1 - squint)));
        ctx.stroke();
      });

      // light blush as it gets cleaner
      if (mood > 0) {
        ctx.fillStyle = `rgba(255, 160, 160, ${0.18 + 0.32 * mood})`;
        ctx.beginPath();
        ctx.ellipse(head.cx - head.rx * 0.26, head.cy + head.ry * 0.05, head.rx * 0.12, head.ry * 0.07, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(head.cx + head.rx * 0.26, head.cy + head.ry * 0.05, head.rx * 0.12, head.ry * 0.07, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = '#eabf9d';
      ctx.beginPath();
      ctx.ellipse(head.cx, head.cy + head.ry * 0.05, head.rx * 0.08, head.ry * 0.09, 0, 0, Math.PI * 2);
      ctx.fill();
      // subtle cheek shadow for depth
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.beginPath();
      ctx.ellipse(head.cx + head.rx * 0.18, head.cy + head.ry * 0.1, head.rx * 0.22, head.ry * 0.12, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawMouth(openRatio = 1, mood = 0) {
      const { mouth } = layout;
      const hScale = 0.9 + openRatio * 0.15;
      const cornerLift = mouth.h * 0.15 * clamp01(mood);
      const lipY = mouth.y + mouth.h * 0.5 - cornerLift * 0.4;
      ctx.save();
      ctx.translate(mouth.x + mouth.w / 2, mouth.y + mouth.h / 2);
      ctx.scale(1, hScale);
      ctx.fillStyle = '#2b0c0c';
      ctx.beginPath();
      ctx.ellipse(0, 0, mouth.w / 2, mouth.h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.fillStyle = '#c95a62';
      ctx.beginPath();
      ctx.roundRect(mouth.x + mouth.w * 0.03, mouth.y + mouth.h * 0.05 - cornerLift * 0.25, mouth.w * 0.94, mouth.h * 0.9, mouth.h * 0.25);
      ctx.fill();

      // mouth outline with lifted corners
      ctx.strokeStyle = '#492222';
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(mouth.x, lipY + cornerLift * 0.2);
      ctx.quadraticCurveTo(mouth.x + mouth.w * 0.5, mouth.y + mouth.h * (0.18 - 0.12 * mood), mouth.x + mouth.w, lipY - cornerLift * 0.2);
      ctx.quadraticCurveTo(mouth.x + mouth.w * 0.5, mouth.y + mouth.h * (0.88 + 0.05 * mood), mouth.x, lipY + cornerLift * 0.25);
      ctx.closePath();
      ctx.stroke();

      ctx.fillStyle = mood > 0 ? '#f58a9d' : '#f07a8c';
      ctx.beginPath();
      ctx.roundRect(mouth.x + mouth.w * 0.18, mouth.y + mouth.h * 0.55, mouth.w * 0.64, mouth.h * 0.38, mouth.h * 0.25);
      ctx.fill();

      // smile lines
      ctx.strokeStyle = '#c46a72';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(mouth.x + mouth.w * 0.1, mouth.y + mouth.h * (0.25 + 0.05 * mood));
      ctx.quadraticCurveTo(mouth.x + mouth.w * 0.5, mouth.y + mouth.h * (0.08 + 0.05 * mood), mouth.x + mouth.w * 0.9, mouth.y + mouth.h * (0.25 + 0.05 * mood));
      ctx.stroke();
    }

    function drawFood(f) {
      ctx.save();
      ctx.translate(f.x, f.y);
      const flash = f.badFlash > 0 ? (0.5 + 0.5 * Math.sin(f.badFlash * 20)) * f.badFlash : 0;
      if (flash > 0) {
        ctx.fillStyle = `rgba(255,70,70,${flash})`;
        ctx.beginPath();
        ctx.arc(0, 0, 26, 0, Math.PI * 2);
        ctx.fill();
      }
      switch (f.type) {
        case 'onigiri':
          ctx.fillStyle = '#fdfdfd';
          ctx.strokeStyle = '#e6e6e6';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, -26);
          ctx.lineTo(24, 16);
          ctx.lineTo(-24, 16);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = '#2e2e2e';
          ctx.fillRect(-14, 4, 28, 18);
          ctx.fillStyle = '#d1b165';
          f.seeds.forEach(s => {
            ctx.beginPath();
            ctx.ellipse(s.x, s.y, s.r, s.r * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
          });
          break;
        case 'steak':
          ctx.fillStyle = '#7b2628';
          ctx.strokeStyle = '#561416';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.roundRect(-28, -18, 56, 36, 10);
          ctx.fill();
          ctx.stroke();
          ctx.strokeStyle = 'rgba(255,210,200,0.6)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-22, -10); ctx.lineTo(18, 8);
          ctx.moveTo(-18, 6); ctx.lineTo(24, -6);
          ctx.moveTo(-10, -2); ctx.lineTo(12, 14);
          ctx.stroke();
          break;
        case 'pork':
          ctx.fillStyle = '#f4c6c0';
          ctx.strokeStyle = '#e2a4a0';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.roundRect(-32, -16, 64, 32, 8);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = '#ffe9e0';
          ctx.fillRect(-32, -4, 64, 10);
          break;
        case 'salmon':
          ctx.fillStyle = '#f48b54';
          ctx.strokeStyle = '#d66a3c';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.roundRect(-30, -14, 60, 28, 10);
          ctx.fill();
          ctx.stroke();
          ctx.strokeStyle = '#ffd9b3';
          ctx.lineWidth = 2;
          for (let i = -20; i <= 20; i += 10) {
            ctx.beginPath();
            ctx.moveTo(i, -10); ctx.lineTo(i + 12, 10);
            ctx.stroke();
          }
          break;
        case 'carrot':
          ctx.fillStyle = '#f28c28';
          ctx.beginPath();
          ctx.moveTo(-16, -18);
          ctx.lineTo(20, 0);
          ctx.lineTo(-16, 18);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#6fbf5f';
          ctx.fillRect(-18, -4, 10, 8);
          break;
        case 'broccoli':
          ctx.fillStyle = '#4d9c4d';
          ctx.beginPath();
          ctx.ellipse(0, -4, 18, 14, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(-12, 2, 12, 10, 0, 0, Math.PI * 2);
          ctx.ellipse(12, 2, 12, 10, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(-4, 4, 8, 14);
          break;
        case 'sausage':
          ctx.fillStyle = '#d06c4f';
          ctx.strokeStyle = '#b9573e';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.roundRect(-26, -12, 52, 24, 12);
          ctx.fill();
          ctx.stroke();
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.beginPath();
          ctx.moveTo(-18, -6); ctx.lineTo(-10, 8);
          ctx.moveTo(0, -8); ctx.lineTo(8, 6);
          ctx.moveTo(14, -4); ctx.lineTo(20, 8);
          ctx.stroke();
          break;
        case 'rock':
          ctx.fillStyle = '#666';
          ctx.beginPath();
          ctx.ellipse(0, 0, 22, 18, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#888';
          ctx.beginPath();
          ctx.ellipse(-6, -4, 8, 6, 0, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'eraser':
          ctx.fillStyle = '#f2f2f2';
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(-18, -10, 36, 20, 4);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = '#4aa3ff';
          ctx.fillRect(-18, -10, 14, 20);
          break;
        case 'pencil':
          ctx.fillStyle = '#f5c14a';
          ctx.beginPath();
          ctx.moveTo(-4, -22);
          ctx.lineTo(18, 0);
          ctx.lineTo(-4, 22);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#d48c3c';
          ctx.fillRect(-4, -22, 10, 44);
          ctx.fillStyle = '#f5d3b5';
          ctx.beginPath();
          ctx.moveTo(-14, 0);
          ctx.lineTo(-4, -8);
          ctx.lineTo(-4, 8);
          ctx.closePath();
          ctx.fill();
          break;
      }
      ctx.restore();
    }

    function drawEat() {
      const w = canvas.width, h = canvas.height;
      drawFaceBase();
      drawMouth(1.15);

      const plateR = w * 0.22;
      ctx.fillStyle = '#f2f5ff';
      ctx.beginPath();
      ctx.ellipse(w * 0.5, h * 0.82, plateR, plateR * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#d5dfef';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(w * 0.5, h * 0.82, plateR * 0.95, plateR * 0.32, 0, 0, Math.PI * 2);
      ctx.stroke();

      foods.forEach(f => {
        if (f.done) return;
        drawFood(f);
      });

      ctx.fillStyle = '#234';
      ctx.font = '22px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('食材をドラッグで口へ。ハズレは時間マイナス！', w / 2, h * 0.2);
      ctx.font = '18px sans-serif';
      ctx.fillText(`食事タイマー: ${Math.ceil(eatTimeLeft)} 秒`, w / 2, h * 0.24);
    }

    function drawFace(mood = 0) {
      drawFaceBase(mood);
      drawMouth(1.0 + mood * 0.1, mood);
      if (mood > 0.55) {
        const s = 10 + mood * 8;
        drawSparkle(layout.mouth.x + layout.mouth.w * 0.2, layout.mouth.y + layout.mouth.h * 0.25, s, 0.6);
        drawSparkle(layout.mouth.x + layout.mouth.w * 0.8, layout.mouth.y + layout.mouth.h * 0.35, s * 0.8, 0.7);
      }
    }

    function drawTooth(t) {
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#d9d9d9';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.roundRect(0, 0, t.w, t.h, 10);
      ctx.fill();
      ctx.stroke();

      const dirt = 100 - t.clean;
      if (dirt > 50) {
        ctx.fillStyle = `rgba(180, 140, 40, ${Math.min(0.9, dirt / 80)})`;
      } else if (dirt > 0) {
        ctx.fillStyle = `rgba(210, 190, 80, ${Math.min(0.65, dirt / 80)})`;
      }
      if (dirt > 0) ctx.fillRect(0, 0, t.w, t.h);

      ctx.fillStyle = '#333';
      ctx.font = `${Math.max(12, t.h * 0.25)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${t.clean.toFixed(0)}%`, t.w / 2, t.h / 2);
      ctx.restore();
    }

    function drawBrush() {
      const handleLen = 80;
      const bristleW = 36;
      const bristleH = 20;
      const angle = -Math.PI / 4;
      ctx.save();
      ctx.translate(lastX, lastY);
      ctx.rotate(angle);
      ctx.fillStyle = '#4aa3ff';
      ctx.fillRect(-handleLen, -6, handleLen, 12);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, -bristleH / 2, bristleW, bristleH);
      ctx.restore();
    }

    function drawOverlay(text, sub) {
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '52px sans-serif';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2 - 10);
      ctx.font = '22px sans-serif';
      ctx.fillText(sub, canvas.width / 2, canvas.height / 2 + 32);
    }

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      update(dt);

      if (mode === 'climb') {
        drawClimb();
        uiAvg.textContent = '-';
        uiTime.textContent = Math.ceil(climbTimeLeft);
        requestAnimationFrame(loop);
        return;
      }

      if (mode === 'eat') {
        drawEat();
        uiAvg.textContent = '-';
        uiTime.textContent = Math.ceil(eatTimeLeft);
        requestAnimationFrame(loop);
        return;
      }

      const avg = teeth.reduce((a, t) => a + t.clean, 0) / teeth.length;
      const mood = clamp01(avg / 100);
      drawFace(mood);
      teeth.forEach(drawTooth);
      drawBrush();

      uiAvg.textContent = avg.toFixed(0);
      uiTime.textContent = Math.ceil(brushTimeLeft);

      if (mode === 'playing' && avg >= 90) {
        mode = 'cleared';
        playClear();
      }

      if (mode === 'cleared') {
        drawOverlay('ピカピカ！ クリア！', '左のボタンでリスタート / さらに磨いてもOK');
      } else if (mode === 'timeoutClimb') {
        drawOverlay('登頂タイムオーバー', '左のボタンでやり直し（山→食事→歯みがき）');
      } else if (mode === 'timeoutEat') {
        drawOverlay('食事タイムオーバー', '左のボタンでやり直し（山→食事→歯みがき）');
      } else if (mode === 'timeoutBrush') {
        drawOverlay('時間切れ', '左のボタンでやり直し（山→食事→歯みがき）');
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
